这是一个基于 Flutter 和 Clean Architecture (整洁架构) 原则设计的企业级 AI 动画师工作台（Enterprise AI Animator Workbench v2.0）。

该项目的设计核心目标是实现一个本地优先（Local-First）、高响应性且可扩展的混合模型流水线，允许专业动画师在不阻塞 UI 的情况下排队处理复杂的 AI 图像任务（如换脸、重绘）。

以下是详细的架构和设计思路阐述：

1. 总体架构：Clean Architecture
项目严格遵循分层架构，将代码分为三层，确保关注点分离和高可测试性：

Domain Layer (领域层): 系统的核心，不依赖于任何外部框架（如 Flutter UI 或数据库）。
Entities: 定义了核心业务对象，如 Asset（资产）、Task（任务）、Project（项目）。
Interfaces (Repositories/Services): 定义了数据存取和业务逻辑的契约（如 IAssetRepository, IGenerativeImageService），但不包含具体实现。
Data Layer (数据层): 负责数据的获取和持久化。
Models (DTOs): AssetModel, TaskModel，负责将领域实体与数据库/API 数据格式进行转换。
Repositories: 实现领域层的接口（如 AssetRepositoryImpl），协调数据源（SQLite, 文件系统, API）。
Data Sources: 具体的数据访问实现，如 DatabaseHelper (SQLite) 和 MockGenerativeImageService (模拟 AI 服务)。
Presentation Layer (表现层): 负责 UI 展示和状态管理。
Widgets/Pages: AssetList, RefinementPanel, AssetDetailsPage。
State Management: 使用 Riverpod 进行状态管理和依赖注入。
2. 核心设计决策
A. 异步任务队列 (Persistent Task Queue)
为了解决 AI 处理耗时导致 UI 卡顿的问题，设计了 TaskQueueService：

持久化: 任务状态（Pending, Processing, Completed, Failed）存储在 SQLite 中。即使应用崩溃或重启，任务状态也不会丢失，可以恢复处理。
解耦: UI 只需要提交任务（queueTask）并监听任务流，不需要关心具体的处理逻辑。
状态驱动: UI 通过 TaskStatusIndicator 实时响应任务状态变化。
B. 资产谱系追踪 (Asset Lineage)
为了满足专业工作流中“版本控制”和“回溯”的需求：

树状结构: Asset 实体包含 parentId 字段。
查询能力: AssetRepository 提供了查询资产谱系的方法，允许用户查看一张图片是由哪张原图经过什么操作（Pipeline Info）生成的。
C. 适配器模式 (Adapter Pattern) for AI Services
为了应对 AI 模型技术的快速迭代：

定义了 IGenerativeImageService 接口。
当前实现为 MockGenerativeImageService 用于开发和测试。
未来扩展: 可以轻松添加 OpenAIGenerativeService 或 StableDiffusionLocalService，只需在依赖注入层（dependency_injection.dart）替换实现即可，无需修改业务逻辑。
D. 本地优先的数据存储
SQLite: 用于存储结构化数据（元数据、任务队列、关系）。选择 SQLite 是因为它支持事务（ACID），保证了任务队列处理的安全性。
文件系统: 用于存储实际的图像/视频二进制文件。
E. 模块化工作台导航 (Modular Workbench Navigation)
为了支持复杂的工作流，采用了 NavigationRail 进行顶级导航，将应用划分为独立的功能模块：
- **Script Workbench**: 专注于剧本导入和 AI 分析。
- **Storyboard Workbench**: 核心创作区，负责分镜管理和资产编辑。
- **Character Workbench**: 角色资产库管理。
- **Settings**: 全局设置。
这种设计使得每个模块可以专注于特定的任务上下文，同时保持全局状态（如当前项目）的一致性。

3. 目录结构 (Feature-First)
采用了按功能分包的策略，所有相关代码都集中在 lib/features/animator_workbench/ 下：

lib/features/animator_workbench/
├── data/
│   ├── datasources/   # 数据库 helper, API 客户端
│   ├── models/        # 数据转换模型 (fromJson/toJson)
│   ├── repositories/  # 仓库实现
│   └── services/      # 具体的业务服务实现 (TaskQueueService)
├── domain/
│   ├── entities/      # 纯 Dart 实体类
│   ├── repositories/  # 仓库接口定义
│   └── services/      # 服务接口定义
└── presentation/
    ├── pages/         # 页面级组件
    ├── providers/     # Riverpod 状态提供者 & 依赖注入
    └── widgets/       # 可复用 UI 组件
4. 关键流程示例
用户发起“换脸”操作的流程：

UI: 用户在 RefinementPanel 输入参数并点击 "Queue Refinement"。
Presentation: 调用 TaskQueueService.queueTask()，创建一个状态为 pending 的 Task。
Data: TaskRepository 将任务写入 SQLite tasks 表。
Service: TaskQueueService 监听到新任务，将其状态更为 processing，并调用 IGenerativeImageService.refineImage()。
UI: 界面上的 AssetList 自动刷新，显示一个带有 TaskStatusIndicator（加载圈）的 PlaceholderCard。
Completion: AI 服务返回结果，TaskQueueService 将新生成的 Asset 写入数据库，并将 Task 标记为 completed。
UI: 占位卡片自动更新为最终生成的图片。
这种设计确保了系统的健壮性（不怕崩溃）、流畅性（UI 不阻塞）和可维护性（模块清晰）。